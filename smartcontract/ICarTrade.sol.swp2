pragma solidity ^0.5;
pragma experimental ABIEncoderV2;

contract ICarTrade{
    /* structure */
    struct Car{
        uint number;
        string owner_name;
        string make;
        string model;
        string color;
        address payable owner;
    }
    
    struct Order{
        Car car;
        uint price;
        string status;
    }

    /* variables */
    uint idx_carReg = 0;
    uint idx_orderReg = 0;

    Car[] registeredCars;
    Order[] registeredOrders;

    mapping(address => string) nameOf;

    /* function */
    /* 차량을 등록하는 함수, 단 판매 목록에 등록은 아님 */ 
    function registerCar(string memory make, string memory model, string memory color) public {
        Car memory newCar = Car(idx_carReg, getName(), make, model, color, msg.sender);
        registeredCars.push(newCar);
        idx_carReg += 1;
    }

    /* 이름 등록 작업 */
    function registerName(string memory name) public {
        nameOf[msg.sender] = name;
    }

    /* 자신의 등록된 차를 오더 목록에 올리는 함수 */
    function sellMyCar(uint cnumber, uint price) public {
        Car memory myCar;
        Order memory myOrder;

        require(registeredCars.length > 0, "there aren't no cars in registeredCar array\n");
        for (uint i = 0; i < registeredCars.length; i++){
            if (registeredCars[i].number != cnumber)
                continue;
            else {
                myCar = registeredCars[i];
                myOrder = Order(myCar, price, "sale");
                registeredOrders.push(myOrder);
            }
        }
    }

    /* 오더 목록에 있는 차량을 등록번호를 통해 구매하는 함수 */
    function buyUserCar(uint orderedcnumber) payable public{
        // 1. 번호에 대응하는 판매 차량을 get
        // 2. transaction 발생
        // 3. transaction이 유효 할경우 소유 주 변경 작업 수행
    }

    /* 오더 시 차량의 소유주에게 이더를 송금하는 함수 */
    function balanceTransfer(address payable seller, uint price) payable public {
        require(msg.sender.balance > price, "Not enough ether to buy car");
        seller.transfer(price);
    }

    /* 차량의 소유주를 변경하는 함수 */
    function changeCarOwner(uint cnumber, address payable addr) public {
        Car memory changeOwner;
        for (uint i = 0; i < registeredCars.length; i++){
            if(registeredCars[i].number != cnumber)
                continue;
            else { 
                changeOwner = registeredCars[i];
                changeOwner.owner_name = nameOf[addr];
                changeOwner.owner = addr;
                return;
            }
        }
    }

    /* 등록된 자신의 모든 차량을 불러오는 함수 */
    function getMyCars() public view returns(Car[] memory){
        // 1. 함수 호출자의 주소 키값에 해당하는 name value값을 get
        // 2. 전체 등록 차량 배열을 루프 회전 
        // 3. 이름 값과 name value가 일치여부 조사
        // 4. 일치 시 로컬 배열 변수에 삽입, 아닐 경우 continue
    }

    /* 주소를 키값으로 이름을 불러오는 작업 */
    function getName() public view returns(string memory){
        return nameOf[msg.sender];
    }

    /* 등록된 모든 차량의 목록을 불러오는 함수, 단 판매중인 차량은 등록된 목록에 표시 하지 않는다? */
    function getAllRegisteredCar() public view returns(Car[] memory){
        Car[] memory currentCars;
        require(registeredCars.length > 0, "there aren't no cars in registeredCars array\n");
        for (uint i = 0; i < registeredCars.length; i++){
            /* check whether currentCar is in order array or not */
        }
        
        return currentCars;
    }
    
    /* 주문 목록의 차량의 목록을 모두 불러오는 함수, 단 구매 완료된 차량은 표시 X */
    function getAllOrderedCar() public view returns(Order[] memory){
        Order[] memory getOrders;
        require(registeredOrders.length > 0, "there aren't no orders in registeredOrders array\n");
        for (uint i = 0; i < registeredOrders.length; i++){
            /* compare status whether input current structure to getOrders or not */
        }

        return getOrders;
    }
}